# pokedex-cli

Assignment: start up interactive REPL (read-eval-print-loop) when you run it

- print a prompt
- wait to type in a command
- print result of that command

start with two commands:

- help: prints a help message describing how to use the REPL
- exit: exits the program

Things it was suggested to look into:

- get input using bufio.NewScanner, .Scan, and .Text

## What the heck is a bufio:

- `bufio` package implements buffered I/O
- wraps an io.Reader or io.Writer object, creating another (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O
- basically, _all_ it does, is add a buffering layer to `os.Stdin`/ Does no parsing or interpreting of the stream at all

### Difference between bufio.NewReader and fmt.Scanln

- fmt.Scanln() reads data from a stream (which may or may not be buffered i.e. returned by the `bufio` package), spliting the input by whitespace, to store in a slice
- Basically fmt.Scan() adds extra post processing that the bufio doesn't have

### Why do you care about buffering?

- A buffer is nothing but a chunk of memory (in a fast place) set aside to store information that normally resides in a slow place (on disk or a network)
- Buffering is about reducing the number of system calls to the OS!
- "For file processing I always recommend using buffered IO. The overhead of doing small reads (reading one byte at a time in my case) is enormous, on some of my projects it was taking nealy 80% of the time (and it wasn't trivial processing)."
- **Main reason: Buffered I/O is a technique used to improve the performance of input and output operations by reducing the number of system calls**

## What is a Scanner in go?

- Scanner is a type that provides a convenient interface for reading data (e.g. file of newline-delimited lines of text)

  ```golang
  type Scanner struct {
      // contains filtered or unexported fields
  }
  ```

- Calls to `.Scan` method will step through the "tokens" of a file, skipping bytes between the [tokens](#tokens)
  - a.k.a. `Scanner` looks for the next token in the input by moving from one token to the next, processing each in turn
- Scanner can be configure to recognize tokens based on specific pattern (like whitespace-delimited words, lines, etc.)

  - "Specification of a token is defined by a split funtion of type `SplitFunc` (default split function breaks input into lines with line termination stripped)

### bufio.newScanner(r io.reader)

- NewScanner returns a new Scanner to read from r (what we get from io)
- The spilt function defaults to `ScanLines`
- apparently we pass an io reader object into scanner

  ```go
  // An artificial input source. (user Input is what we would replace this dummy data with)
  const input = "1234 5678 1234567901234567890"
  scanner := bufio.NewScanner(strings.NewReader(input))
  ```

### `Scan` method

- `func (s *Scanner) Scan() bool`
- Scan advances the Scanner to the next token, which will then be available through Bytes or **Text** method
- Returns false when the scan stops (either by reaching end of input or an error)
  - After Scan returns false, the Err method returns any error (some type of err != nill method to do a set of instructions as long as scanner is scanning)
- Common failure method: Scan panics if split function returns too many empty tokens without advancing input

### `Text` method

- `func (s *Scanner) Split(split SplitFunc)`
- Text returns most recent token generated by a call to scan as a newly allocated string holding it's bytes (if token is a word, then text will return that word)

Example code:

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    scanner := bufio.NewScanner(os.Stdin)
    for scanner.Scan() {
        fmt.Println(scanner.Text()) // Println will add back the final '\n'
    }
    if err := scanner.Err(); err != nil {
        fmt.Fprintln(os.Stderr, "reading standard input:", err)
    }
}
```

## Step 2: POKEAPI

In this assignment, I'm tasked with making two commands that retrieve data for the PokeAPI and display it in cli

### Building map command

- First: add command to commandMap
- Todo:

  - figure out how to call api in Go

    1. Create a function that calls api and prints the returned JSON

    - expect api to return JSON of this form

      ```json
      {
        "count": 248,
        "next": "https://pokeapi.co/api/v2/ability/?limit=20&offset=20",
        "previous": null,
        "results": [
          {
            "name": "stench",
            "url": "https://pokeapi.co/api/v2/ability/1/"
          }
        ]
      }
      ```

  - figure out a way to store the data the api returns
    - need to create some type of struct to store each location!
  - figure out a way to store the previous url so I'll be able to implemnt back functionality

### Learnings

#### Go HTTP Response Handling

In Node.js (where I was coming from) apparently a lot of the underlying complexity of requests are extracted away (by high-level libraries like Express).

Go, on the other hand, exposes a lot more of the underlying mechanics of web protocols! In reality, when you request to a server, you receive a stream of bytes
In Go, when you receive a response, you actually get an `io.ReadCloser` stream in `res.Body`. You have to be the one to determine how to read the stream and interpret it's content!

Why use `io.ReadAll`?

Since the `res.Body` object is a _stream_, it does NOT come directly as a JSON object... You have to use `io.ReadAll` to actually read the stream completely into memory!

Once the data is in memory, you can parse it into JSON if you want

#### Parsing JSON in Go

In order to parse the JSON for the PokeAPI, first need to create structs to save the json into.

Then you actually have to unmarshal the JSON to the corresponding struct

##### What is marshalling and unmarshalling?

- **Marshalling** - Act of converting a Go data structure into valid JSON
- **Unmarshalling** - Act of parsing a valid JSON string into a data structure in Go

In other languages, _marshalling_ is known as "serializing" and _unmarshalling_ is known as "deserializing"

## Glossary

### Tokens

What is a token?

- In programming, a **token** is the smallest element tha that has semantic meaning in text
  - Could be words, numbers, punctuation, operators, e.t.c. depending on the context and the rules defined for tokenization
- Example: in a text file containing the sentence "Hello, world!", tokens might be "Hello", ",", "world", and "!"

Skipping bytes between tokens?!

- Phrase means that the `Scanner` ignores the parts of the input that don't qualify as tokens based on the defined rules
- Example: in a text file, if tokens are defined as words seperated by spaces, _the spaces themselves_ are skipped as the `Scanner` moves from one word (which is the token in this example) to the next.
